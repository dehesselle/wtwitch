#!/bin/bash
#
# Description: Browse and watch Twitch without being tracked.
#
# Copyright (C) 2019-2020:
readonly CONTRIBUTORS="krathalan"
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

# -----------------------------------------
# -------------- Guidelines ---------------
# -----------------------------------------

# This script follows the Google Shell Style Guide:
# https://google.github.io/styleguide/shell.xml

# This script uses shellcheck: https://www.shellcheck.net/
# There are no "shellcheck disable=SCXXXX" lines in this script.

# Many functions in this script spawn subshell processes
trap "clean_up && kill 0" SIGINT

# See https://vaneyckt.io/posts/safer_bash_scripts_with_set_euxo_pipefail/
set -Eeuo pipefail

# -----------------------------------------
# ----------- Program variables -----------
# -----------------------------------------

# Script (self) information
readonly SCRIPT_NAME=$(basename "$0")
readonly PROJECT_URL="https://git.sr.ht/~krathalan/wtwitch"
readonly VERSION="1.3.0"

# Colors
readonly GREEN=$(tput bold && tput setaf 2)
readonly GREY=$(tput setaf 8)
readonly LIGHTGREEN=$(tput setaf 10)
readonly NC=$(tput sgr0) # No color/turn off all tput attributes
readonly ORANGE=$(tput setaf 3)
readonly PURPLE=$(tput setaf 13)
readonly RED=$(tput bold && tput setaf 1)
readonly TURQOISE=$(tput setaf 6)

# Locale file
readonly LANG_FILE="/usr/lib/wtwitch/locale.json"

# Subscription check cache
readonly CACHE_EXPIRY_TIME="60" # In seconds
readonly CACHE_FILE_DIRECTORY="${HOME}/.cache/${SCRIPT_NAME}"
readonly CACHE_OFFLINE_TEXT_FILE="${CACHE_FILE_DIRECTORY}/stream_offline.txt"
readonly CACHE_ONLINE_TEXT_FILE="${CACHE_FILE_DIRECTORY}/stream_online.txt"

# Used by list_streamers_of_game() and list_top()
readonly CACHE_MISC_TEXT_FILE="${CACHE_FILE_DIRECTORY}/stream_misc.txt"
# Used exclusively by list_top()
readonly CACHE_TOP_STREAMS_TEXT_FILE="${CACHE_FILE_DIRECTORY}/stream_top_streamers.txt"

# Used to reduce strain on Twitch API
readonly CACHE_GAME_ID_FILE="${CACHE_FILE_DIRECTORY}/gameids.json"

# Config
readonly CONFIG_FILE_DIRECTORY="${HOME}/.config/${SCRIPT_NAME}"
readonly CONFIG_FILE="${CONFIG_FILE_DIRECTORY}/config.json"

# Used to calculate output string lengths (see check_twitch_streams_helper()
# and list_streamers_of_game_helper())
# Why is TITLE_CHARACTERS=18? Because that's how many characters will always
# be present in a printed line; ergo they must be subtracted from the total
# terminal width to get the effective maximum line length.
readonly TITLE_CHARACTERS=18
readonly TERMINAL_WIDTH=$(tput cols)

# Used by check_twitch_streams() for asynchronous loading of user subscriptions
readonly LOAD_SUBS_FILE="${CACHE_FILE_DIRECTORY}/subs.tmp"

# Twitch API information
# This API key is intended to be used for wtwitch only -- do not use this API
# key for any other reason!
readonly TWITCH_API_URL="https://api.twitch.tv"
readonly TWITCH_API_KEY="cotxsalhlctv8z572f7fant4b0sc3u"

# Debugging
if [[ "$*" == *"-d"* ]] || [[ "$*" == *"--debug"* ]]; then
  # Avoid subshells, print full wget output, and more behavioral changes
  readonly DEBUGGING="on"

  # Print log information
  readonly _dashes="-----------------------------------------------------------"

  if pacman -Q wtwitch &> /dev/null; then
    readonly _packageinfo="installed via pacman"
  else
    readonly _packageinfo="script or unknown"
  fi

  printf "Starting wtwitch debug log\nPackage: %s\nVersions: wtwitch-%s %s\nDate: %s\n\nCommand: wtwitch %s\n\nConfig file:\n\n%s\n\n%s\nBegin log\n%s\n\n" "${_packageinfo}" "${VERSION}" "$(jq --version) $(streamlink --version)" "$(date)" "$*" "$(jq -r "." "${CONFIG_FILE}")" "${_dashes}" "${_dashes}"

  # Print all commands
  set -x
else
  readonly DEBUGGING="off"
fi

# -----------------------------------------
# ------------- User variables ------------
# -----------------------------------------

# Values are loaded from $CONFIG_FILE (see load_config())
useColors=""
userPlayer=""
userQuality=""
userSubscriptions=()

# -----------------------------------------
# --------------- Functions ---------------
# -----------------------------------------

#######################################
# Changes the default player in $CONFIG_FILE that gets passed to streamlink.
# Globals:
#   Colors: ORANGE, NC
# Arguments:
#   $1: player to set as default
# Returns:
#   none
#######################################
change_player()
{
  local -r workingPlayers=("gnome-mpv" "mpv" "mplayer" "vlc")
  local passedCheckMarker="false"

  # Convert user input to lowercase
  local -r playerName="${1,,}"

  # Check to make sure user has input player actually installed
  if [[ ! -x "$(command -v "${playerName}")" ]]; then
    exit_script_on_failure "Media player ${playerName} not found."
  fi

  # Check against known working players
  for i in "${workingPlayers[@]}"; do
    if [[ "${playerName}" == "${i}" ]]; then
      passedCheckMarker="true"
    fi
  done

  if [[ "${passedCheckMarker}" != "true" ]]; then
    printf "\n %sWarning%s: player %s may not work properly with Streamlink.\n" "${ORANGE}" "${NC}" "${playerName}"
  fi

  write_setting ".player" "${playerName}"
}

#######################################
# Changes the default quality in $CONFIG_FILE that gets passed to streamlink.
# Globals:
#   none
# Arguments:
#   $1: quality to set as default, e.g. "1080p60,720p60,best"
# Returns:
#   none
#######################################
change_quality()
{
  local -r acceptableQualities=("audio_only" "worst" "160p" "360p" "480p" "720p" "720p60" "1080p60" "best")
  local passedCheckMarkerArray=()

  # Convert user input to lowercase
  local -r specifiedQuality="${1,,}"

  # User may try and enter fallback qualities; code should account for this
  IFS=',' read -r -a qualityArray <<< "$specifiedQuality"

  # For each quality the user has specified
  for i in "${qualityArray[@]}"; do
    # Check to make sure it's an acceptable quality
    for j in "${acceptableQualities[@]}"; do
      if [[ "${i}" == "${j}" ]]; then
        passedCheckMarkerArray+=("true")
      fi
    done
  done

  # Make sure there are an equal number of "true" elements in passedCheckMarkers as there are qualities in specifiedQuality
  if [[ ${#qualityArray[@]} -eq ${#passedCheckMarkerArray[@]} ]]; then
    write_setting ".quality" "${specifiedQuality}"
  else
    exit_script_on_failure "Quality ${specifiedQuality} is not an acceptable quality. 1080p60, 720p60, 720p, 480p, 360p, 160p, best, worst, and audio_only are acceptable qualities. You can specify fallback qualities separated by a comma, e.g. \"720p,480p,worst\"."
  fi
}

#######################################
# Creates the cache and config directories and files if they are missing.
# Globals:
#   CACHE_FILE_DIRECTORY
#   CONFIG_FILE
#   CONFIG_FILE_DIRECTORY
# Arguments:
#   $1: command to test
# Returns:
#   none
#######################################
check_files()
{
  # Create config file if it doesnt exist
  if [[ ! -f "${CONFIG_FILE}" ]]; then
    if [[ ! -d "${CONFIG_FILE_DIRECTORY}" ]]; then
      mkdir -p "${CONFIG_FILE_DIRECTORY}"
    fi

    # Default config
    printf "{\"player\": \"mpv\",\"quality\": \"best\",\"colors\": \"true\",\"subscriptions\": []}" > "${CONFIG_FILE}"
  fi

  # Create cache folder if it doesn't exist
  if [[ ! -d "${CACHE_FILE_DIRECTORY}" ]]; then
    mkdir -p "${CACHE_FILE_DIRECTORY}"
  fi

  # Create gameids cache file
  if [[ ! -f "${CACHE_GAME_ID_FILE}" ]]; then
    printf "{\"data\": []}" > "${CACHE_GAME_ID_FILE}"
  fi
}

#######################################
# Checks to see which subscribed Twitch streams are online and prints the user's settings.
# Globals:
#   CACHE_EXPIRY_TIME
#   CACHE_OFFLINE_TEXT_FILE
#   CACHE_ONLINE_TEXT_FILE
#   CONFIG_FILE
#   DEBUGGING
#   LOAD_SUBS_FILE
#   userPlayer
#   userQuality
#   userSubscriptions
# Arguments:
#   none
# Returns:
#   none
#######################################
check_twitch_streams()
{
  load_subs --async &
  load_config

  wait

  # Manually assign userSubscriptions due to asynchronous sub loading
  mapfile -t userSubscriptions < "${LOAD_SUBS_FILE}"

  printf "\n %s:" "$(get_localized_string "check_online")"

  # Check cache expiry time
  local dateDiff="0"
  local lastSubscriptionUpdate
  lastSubscriptionUpdate=$(jq -r ".lastSubscriptionUpdate" "${CONFIG_FILE}")

  # Check for older (e.g. "Sun Nov  3 14:54:55 PST 2019") style lastSubscriptionUpdate
  if ! [[ "${lastSubscriptionUpdate}" =~ ^[0-9]+$ ]] ; then
    lastSubscriptionUpdate=0
  fi

  if [[ "${lastSubscriptionUpdate}" != "null" ]]; then
    local -r currentDate=$(LANG=C date +%s -d "now")
    dateDiff=$(( currentDate - lastSubscriptionUpdate ))
  fi

  # If the last subsription update is null (e.g. the subscriptions have never been checked), OR
  # if the time between now and the last subscription update is greater than the cache expiry time, OR
  # if either of the cache files do NOT exist yet
  if  [[ "${lastSubscriptionUpdate}" == "null" ]] || [[ $dateDiff -gt $CACHE_EXPIRY_TIME ]] \
  || [[ ! -f "${CACHE_ONLINE_TEXT_FILE}" ]] || [[ ! -f "${CACHE_OFFLINE_TEXT_FILE}" ]]; then
    # Remove old cache files
    clean_up

    # Ensure that both CACHE_ONLINE_TEXT_FILE and CACHE_OFFLINE_TEXT_FILE get written to; sometimes all streamers are online or offline
    touch "${CACHE_ONLINE_TEXT_FILE}" "${CACHE_OFFLINE_TEXT_FILE}"
    
    # Build inital request URL
    local initialRequestURL="${TWITCH_API_URL}/helix/streams?"

    for stream in "${userSubscriptions[@]}"; do
      initialRequestURL+="user_login=${stream}&"
    done

    # Get data of all online streamers (sans game names)
    local -r allStreamerJson=$(download_file "${initialRequestURL}")

    # Figure out offline streamers in background
    get_offline_streams "${allStreamerJson}"

    # Pass each streamer json data to check_twitch_streams_helper to parse, 
    # get game name for, and print
    local whileCounter=0

    local streamerToProcess=""
    streamerToProcess=$(jq -r ".data[${whileCounter}]" <<< "${allStreamerJson}")

    while [[ "${streamerToProcess}" != "null" ]]; do
      # Don't use subshells when debugging is on
      if [[ "${DEBUGGING}" == "on" ]]; then
        check_twitch_streams_helper "${streamerToProcess}"
      else
        check_twitch_streams_helper "${streamerToProcess}" &
      fi

      # Refresh data
      whileCounter=$(( whileCounter + 1 ))
      streamerToProcess=$(jq -r ".data[${whileCounter}]" <<< "${allStreamerJson}")
    done

    # Wait for all background processes, offline and online, to finish
    wait

    # Update lastSubscriptionUpdate time
    write_setting ".lastSubscriptionUpdate" "$(LANG=C date +%s -d "now")"
  fi

  printf "\n"

  sort "${CACHE_ONLINE_TEXT_FILE}" 2> /dev/null

  printf "\n %s:\n" "$(get_localized_string "check_offline")"

  sort "${CACHE_OFFLINE_TEXT_FILE}" 2> /dev/null

  # Print settings
  printf "\n %s:\n   %s %s\n   %s %s\n" "$(get_localized_string "check_settings")" "$(get_localized_string "check_player")" "${userPlayer}" "$(get_localized_string "check_quality")" "${userQuality}"
}

#######################################
# Used by check_twitch_streams to figure out the streamers that are offline.
# Globals:
#   DEBUGGING
#   userSubscriptions
# Arguments:
#   $1: "${allStreamerJson}" to compare with user subscriptions
# Returns:
#   none
#######################################
get_offline_streams()
{
  for streamerName in "${userSubscriptions[@]}"; do
    # Don't use subshells if debugging is on
    if [[ "${DEBUGGING}" == "on" ]]; then
      get_offline_streams_helper "${streamerName}" "$1"
    else
      get_offline_streams_helper "${streamerName}" "$1" &
    fi
  done
}

#######################################
# Used by get_offline_streams to figure out the streamers that are offline.
# Globals:
#   Colors: NC, GREY
#   CACHE_OFFLINE_TEXT_FILE
# Arguments:
#   $1: streamer to check
#   $2: "${allStreamerJson}" to compare with streamer
# Returns:
#   none
#######################################
get_offline_streams_helper()
{
  if ! grep -qi "$1" <<< "$2"; then
    if [[ "${useColors}" == "true" ]]; then
      printf "   %s%s%s\n" "${GREY}" "$1" "${NC}" >> "${CACHE_OFFLINE_TEXT_FILE}"
    else
      printf "   %s\n" "$1" >> "${CACHE_OFFLINE_TEXT_FILE}"
    fi
  fi
}

#######################################
# Returns the game name for a specified game ID. Attempts to get game name from
# cache, but if game ID not present, retrieves it from the Twitch API.
# Globals:
#   CACHE_GAME_ID_FILE
# Arguments:
#   $1: game ID to get game name of
# Returns:
#   game name of specified ID
#######################################
get_game_name()
{
  # Add "id" prefix as jq does not accept numerical identifiers
  local -r gameID="id$1"

  # Attempt to extract game name from cached game ids
  local gameName
  gameName="$(jq -r ".data | add | .${gameID}" "${CACHE_GAME_ID_FILE}")"

  # If game id not cached, fetch from Twitch API
  if [[ "${gameName}" == "" ]] || [[ "${gameName}" == "null" ]]; then
    local tmpJson
    tmpJson=$(download_file "${TWITCH_API_URL}/helix/games?id=$1")
    gameName="$(jq -r ".data[0].name" <<< "${tmpJson}")"

    # Cache result for future reference
    tmpJson=$(jq ".data[.data | length] |= . + {\"${gameID}\":\"${gameName}\"}" "${CACHE_GAME_ID_FILE}")
    printf "%s" "${tmpJson}" > "${CACHE_GAME_ID_FILE}"
  fi

  printf "%s" "${gameName}"
}

#######################################
# Used by check_twitch_streams to facilitate multi-process fetching and parsing of json files.
# Globals:
#   Colors: LIGHTGREEN, NC, ORANGE, GREY
#   CACHE_OFFLINE_TEXT_FILE
#   CACHE_ONLINE_TEXT_FILE
#   TERMINAL_WIDTH
#   TITLE_CHARACTERS
#   TWITCH_API_URL
# Arguments:
#   none
# Returns:
#   none
#######################################
check_twitch_streams_helper()
{
  # Get current info of streamer
  local -r streamerJson="$1"
  local userName
  userName=$(jq -r ".user_name" <<< "${streamerJson}")

  # Get stream game name from game ID
  local streamGame
  streamGame="$(get_game_name "$(jq -r ".game_id" <<< "${streamerJson}")")"

  # Get streamer-set stream name
  # Truncate stream name if necessary; some streamers have excessively long stream titles
  local -r maxTitleLength=$(( TERMINAL_WIDTH - TITLE_CHARACTERS - ${#streamGame} - ${#userName} + 7))
  local streamName
  streamName=$(jq -r ".title[0:${maxTitleLength}]" <<< "${streamerJson}")

  if [[ "${#streamName}" == "${maxTitleLength}" ]]; then
    streamName+="…"
  fi

  if [[ "${useColors}" == "true" ]]; then
    printf "   %s%s%s: %s %s(%s)%s\n" "${LIGHTGREEN}" "${userName}" "${NC}" "${streamName}" "${ORANGE}" "${streamGame}" "${NC}" >> "${CACHE_ONLINE_TEXT_FILE}"
  else
    printf "   %s: %s (playing %s)\n" "${userName}" "${streamName}" "${streamGame}" >> "${CACHE_ONLINE_TEXT_FILE}"
  fi
}

#######################################
# Cleans up temporary file(s).
# Globals:
#   CACHE_ONLINE_TEXT_FILE
#   CACHE_OFFLINE_TEXT_FILE
#   LOAD_SUBS_FILE
# Arguments:
#   none
# Returns:
#   none
#######################################
clean_up()
{
  # Clean up
  rm -f "${CACHE_ONLINE_TEXT_FILE}" "${CACHE_OFFLINE_TEXT_FILE}" "${CACHE_MISC_TEXT_FILE}" "${CACHE_TOP_STREAMS_TEXT_FILE}" "${LOAD_SUBS_FILE}"
}

#######################################
# Downloads a file quietly using wget and passes the TWITCH_API_KEY as a header to the server. Returns the downloaded file.
# Globals:
#   DEBUGGING
#   TWITCH_API_KEY
# Arguments:
#   $1: file to download
# Returns:
#   downloaded file
#######################################
download_file()
{
  # Do not pass --quiet flag to wget if debugging
  if [[ "${DEBUGGING}" == "on" ]]; then
    wget --output-document=- --header="Client-ID: ${TWITCH_API_KEY}" "$1"
  else
    wget --quiet --output-document=- --header="Client-ID: ${TWITCH_API_KEY}" "$1"
  fi
}

#######################################
# Prints passed error message before premature exit. Prints everything to >&2 (STDERR).
# Globals:
#   Colors: RED, NC
#   SCRIPT_NAME
# Arguments:
#   $1: error message to print
# Returns:
#   none
#######################################
exit_script_on_failure()
{
  if [[ $# -gt 0 ]]; then
    printf "\n %sError%s: %s\n\n Exiting %s.\n%s" "${RED}" "${NC}" "$1" "${SCRIPT_NAME}" "${NC}" >&2
  fi

  clean_up
  exit 1
}

#######################################
# Prints the requested string in the current system locale.
# Globals:
#   LANG
#   LANG_FILE
# Arguments:
#   $1: string to print
# Returns:
#   none
#######################################
get_localized_string()
{
  printf "%s" "$(jq -r ".$1.${LANG%_*}" "${LANG_FILE}")"
}

#######################################
# Lists the top streamers for a specified game.
# Globals:
#   CACHE_MISC_TEXT_FILE
#   DEBUGGING
#   TWITCH_API_URL
# Arguments:
#   $1: game to list top streamers of
# Returns:
#   none
#######################################
list_streamers_of_game()
{
  # Load config for useColors
  load_config

  printf "\n %s streamers:\n" "$1"

  # Replace spaces in game name with %20 for URL
  local -r gameName=${1// /%20}

  # Get game_id
  local twitchJson
  twitchJson=$(download_file "${TWITCH_API_URL}/helix/games?name=${gameName}")

  local -r gameID=$(jq -r ".data[0].id" <<< "${twitchJson}")

  # Get streamers
  twitchJson=$(download_file "${TWITCH_API_URL}/helix/streams?game_id=${gameID}")
  
  # Remove old cache files
  clean_up

  local whileCounter=0

  local streamerName=""
  streamerName=$(jq -r ".data[${whileCounter}].user_name" <<< "${twitchJson}")

  while [[ "${streamerName}" != "null" ]]; do
    # Don't use subshells when debugging is on
    if [[ "${DEBUGGING}" == "on" ]]; then
      print_stream_info "${whileCounter}" "${twitchJson}" "${streamerName}" "${CACHE_MISC_TEXT_FILE}"
    else
      print_stream_info "${whileCounter}" "${twitchJson}" "${streamerName}" "${CACHE_MISC_TEXT_FILE}" &
    fi

    # Refresh data
    whileCounter=$(( whileCounter + 1 ))
    streamerName=$(jq -r ".data[${whileCounter}].user_name" <<< "${twitchJson}")
  done

  wait

  if [[ -f "${CACHE_MISC_TEXT_FILE}" ]]; then
    cat "${CACHE_MISC_TEXT_FILE}"
  else
    printf " No one is streaming %s.\n" "$1"
  fi
}

#######################################
# Facilitates multi-process parsing of json files.
# Globals:
#   Colors: TURQOISE, NC, ORANGE
#   CACHE_MISC_TEXT_FILE
#   TERMINAL_WIDTH
#   TITLE_CHARACTERS
# Arguments:
#   $1: index of streamer to print info of
#   $2: json file containing streamer data
#   $3: name of streamer
#   $4: file to print to
#   $5: if this argument exists, print game of stream
# Returns:
#   none
#######################################
print_stream_info()
{
  local index="$1"
  local twitchJson="$2"
  # name of streamer = $3

  # Get streamer-set stream name
  local streamName=""

  # Get number of current stream viewers
  local viewers=""
  viewers=$(jq -r ".data[${index}].viewer_count" <<< "${twitchJson}")

  # Add game name to final string if $5 is present
  local additionalText=""
  if [[ $# -gt 4 ]]; then
    additionalText="$(get_game_name "$(jq -r ".data[${index}].game_id" <<< "${twitchJson}")"), "
  fi

  # Truncate stream name if necessary
  local -r maxTitleLength=$(( TERMINAL_WIDTH - TITLE_CHARACTERS - ${#3} - ${#additionalText} - ${#viewers} ))
  local streamName
  streamName=$(jq -r ".data[${index}].title[0:${maxTitleLength}]" <<< "${twitchJson}")

  if [[ "${#streamName}" == "${maxTitleLength}" ]]; then
    streamName+="…"
  fi

  if [[ "${useColors}" == "true" ]]; then
    printf "   %s%s%s: %s %s(%s%s viewers)%s\n" "${TURQOISE}" "$3" "${NC}" "${streamName}" "${ORANGE}" "${additionalText}" "${viewers}" "${NC}" >> "$4"
  else
    printf "   %s: %s (%s viewers)\n" "$3" "${streamName}" "${viewers}" >> "$4"
  fi
}

#######################################
# Lists the top games and streamers on Twitch.
# Globals:
#   Colors: PURPLE, NC
#   CACHE_MISC_TEXT_FILE
#   CACHE_TOP_STREAMS_TEXT_FILE
#   DEBUGGING
#   TWITCH_API_URL
#   useColors
# Arguments:
#   none
# Returns:
#   none
#######################################
list_top()
{
  # Load config for useColors
  load_config

  printf "\n Top games:\n"

  # Remove old cache files
  clean_up

  # Start figuring out top streamers - don't use subshells when debugging is on
  if [[ "${DEBUGGING}" == "on" ]]; then
    list_top_streams
  else
    list_top_streams &
  fi

  # Figure out top games in foreground
  local -r topGamesJson=$(download_file "${TWITCH_API_URL}/helix/games/top")

  local whileCounter=0

  local gameName=""
  gameName=$(jq -r ".data[${whileCounter}].name" <<< "${topGamesJson}")

  while [[ "${gameName}" != "null" ]]; do
    if [[ "${useColors}" == "true" ]]; then
      printf "   %s. %s%s%s\n" $(( whileCounter + 1 )) "${PURPLE}" "${gameName}" "${NC}" >> "${CACHE_MISC_TEXT_FILE}"
    else
      printf "   %s. %s\n" $(( whileCounter + 1 )) "${gameName}" >> "${CACHE_MISC_TEXT_FILE}"
    fi

    # Refresh data
    whileCounter=$(( whileCounter + 1 ))
    gameName=$(jq -r ".data[${whileCounter}].name" <<< "${topGamesJson}")
  done

  # Wait for list_top_streams() to finish
  wait

  cat "${CACHE_MISC_TEXT_FILE}"

  printf "\n Top streams:\n"
  cat "${CACHE_TOP_STREAMS_TEXT_FILE}"
}

#######################################
# Lists the top streams on Twitch.
# Globals:
#   CACHE_TOP_STREAMS_TEXT_FILE
#   DEBUGGING
#   TWITCH_API_URL
# Arguments:
#   none
# Returns:
#   none
#######################################
list_top_streams()
{
  local -r topStreamsJson=$(download_file "${TWITCH_API_URL}/helix/streams?first=20")

  local whileCounter=0

  local streamerName=""
  streamerName=$(jq -r ".data[${whileCounter}].user_name" <<< "${topStreamsJson}")

  while [[ "${streamerName}" != "null" ]]; do
    # Don't use subshells when debugging is on
    if [[ "${DEBUGGING}" == "on" ]]; then
      print_stream_info "${whileCounter}" "${topStreamsJson}" "${streamerName}" "${CACHE_TOP_STREAMS_TEXT_FILE}" "print_game"
    else
      print_stream_info "${whileCounter}" "${topStreamsJson}" "${streamerName}" "${CACHE_TOP_STREAMS_TEXT_FILE}" "print_game" &
    fi

    # Refresh data
    whileCounter=$(( whileCounter + 1 ))
    streamerName=$(jq -r ".data[${whileCounter}].user_name" <<< "${topStreamsJson}")
  done

  wait
}

#######################################
# Loads user player and quality settings from $CONFIG_FILE (usually ~/.config/wtwitch/config.json).
# Globals:
#   CONFIG_FILE
#   useColors
#   userPlayer
#   userQuality
# Arguments:
#   none
# Returns:
#   none
#######################################
load_config()
{
  # Make sure cache and config directories exist
  check_files

  # Load settings
  useColors=$(jq -r ".colors" "${CONFIG_FILE}")
  userPlayer=$(jq -r ".player" "${CONFIG_FILE}")
  userQuality=$(jq -r ".quality" "${CONFIG_FILE}")
}

#######################################
# Loads user subscriptions from $CONFIG_FILE (usually ~/.config/wtwitch/config.json).
# Globals:
#   CONFIG_FILE
#   LOAD_SUBS_FILE
#   userSubscriptions
# Arguments:
#   $1: flag for --async to map userSubscriptions manually after load_subs &
# Returns:
#   none
#######################################
load_subs()
{
  # Make sure cache directory and config file exists
  check_files

  # Erase possible existing temp file
  rm -f "${LOAD_SUBS_FILE}"
  touch "${LOAD_SUBS_FILE}"

  local whileCounter=0
  local -r numberOfSubs=$(jq ".subscriptions | length" "${CONFIG_FILE}")

  while [[ ${whileCounter} -lt ${numberOfSubs} ]]; do
    load_subs_helper "${whileCounter}" &
    whileCounter=$(( whileCounter + 1 ))
  done

  wait

  if [[ $# -gt 0 ]]; then
    if [[ "$1" != "--async" ]]; then
      mapfile -t userSubscriptions < "${LOAD_SUBS_FILE}"
    fi
  fi
}

#######################################
# Used by load_subs to facilitate multi-process parsing of json files.
# Globals:
#   CONFIG_FILE
#   LOAD_SUBS_FILE
# Arguments:
#   $1: index of streamer to get name of
# Returns:
#   none
#######################################
load_subs_helper()
{
  printf "%s\n" "$(jq -r ".subscriptions[$1].streamer" "${CONFIG_FILE}")" >> "${LOAD_SUBS_FILE}"
}

#######################################
# Prints information about how to use this script.
# Globals:
#   PROJECT_URL
# Arguments:
#   none
# Returns:
#   none
#######################################
print_help()
{
  man wtwitch || exit_script_on_failure "View the man page at ${PROJECT_URL}/tree/${VERSION}/wtwitch.1.scd"
}

#######################################
# Opens a stream with Streamlink.
# Globals:
#   TWITCH_API_URL
#   userPlayer
#   userQuality
# Arguments:
#   $1: name of streamer to watch
# Returns:
#   none
#######################################
stream()
{
  # Use VLC as backup player if mpv is not installed
  if [[ ! -x "$(command -v "${userPlayer}")" ]]; then
    if [[ -x "$(command -v "vlc")" ]]; then
      userPlayer="vlc"
    else
      stream_failure_notify "$1" "Media player ${userPlayer} not found."
    fi
  fi

  # Check to make sure streamer is online
  # Get current info of streamer
  local -r streamerJson=$(download_file "${TWITCH_API_URL}/helix/streams?user_login=$1")

  if [[ "$(jq -r ".data[0].type" <<< "${streamerJson}")" == "null" ]]; then
    stream_failure_notify "$1" "Streamer $1 is not online."
  fi

  # If using mpv: add window title, enable hardware dec, and use wayland if possible
  if [[ "${userPlayer}" == "mpv" ]]; then
    userPlayer+=" --hwdec=auto"

    if [[ $(pgrep wayland) || $(pgrep sway) ]]; then
      userPlayer+=" --gpu-context=wayland"
    fi

    streamlink -p "${userPlayer}" --title "Watching $1 on Twitch (\\\${{video-params/h}}p \\\${{estimated-vf-fps}}fps)" --twitch-disable-ads "https://www.twitch.tv/$1" "${userQuality}" || stream_failure_notify "$1" "$1's stream does not support quality ${userQuality}."
  else
    streamlink -p "${userPlayer}" --twitch-disable-ads "https://www.twitch.tv/$1" "${userQuality}" || stream_failure_notify "$1" "$1's stream does not support quality ${userQuality}."
  fi
}

#######################################
# Notifies the user if streaming failed.
# Globals:
#   none
# Arguments:
#   $1: name of streamer
#   $2: error message to print
# Returns:
#   none
#######################################
stream_failure_notify()
{
  notify-send -i "gnome-twitch" "Wtwitch: streaming $1 failed" "$2"
  exit_script_on_failure
}

#######################################
# Subscribes to a specific streamer.
# Globals:
#   CONFIG_FILE
# Arguments:
#   $1: streamer to subscribe to
# Returns:
#   none
#######################################
subscribe()
{
  load_subs --no-async

  # Convert to lowercase
  local -r streamerToSubscribeTo="${1,,}"

  # Check to make sure user isn't already subscribed
  if [[ ${#userSubscriptions[@]} -gt 0 ]]; then
    local whileCounter=0

    local currentSubscription
    currentSubscription="${userSubscriptions[${whileCounter}]}"

    while [[ ${whileCounter} -lt ${#userSubscriptions[@]} ]] && [[ "${currentSubscription}" != "${streamerToSubscribeTo}" ]]; do
      # Refresh data
      currentSubscription="${userSubscriptions[${whileCounter}]}"
      whileCounter=$(( whileCounter + 1))
    done

    if [[ "${currentSubscription}" == "${streamerToSubscribeTo}" ]]; then
      exit_script_on_failure "You are already subscribed to ${streamerToSubscribeTo}."
    fi
  fi

  # Add subscription (can't use write_setting here due to unique jq syntax)
  local -r tmpJson=$(jq ".subscriptions[.subscriptions | length] |= . + {\"streamer\":\"$streamerToSubscribeTo\"}" "${CONFIG_FILE}")
  printf "%s" "${tmpJson}" > "${CONFIG_FILE}"

  # Invalidate cache
  write_setting ".lastSubscriptionUpdate" "null"
}

#######################################
# Changes the useColor value in $CONFIG_FILE that determines if wtwitch output is colorful.
# Globals:
#   Colors: GREEN, NC
#   useColors
# Arguments:
#   none
# Returns:
#   none
#######################################
toggle_colors()
{
  load_config

  # Reverse "colors" value
  if [[ "${useColors}" == "true" ]]; then
    write_setting ".colors" "false"
    printf "\n Turned colors OFF.\n"
  else
    write_setting ".colors" "true"
    printf "\n %sTurned colors ON.%s\n" "${GREEN}" "${NC}"
  fi

  # Invalidate cache as it may or may not have colors
  write_setting ".lastSubscriptionUpdate" "null"
}

#######################################
# Unsubscribes from a specific streamer.
# Globals:
#   CONFIG_FILE
# Arguments:
#   $1: streamer to unsubscribe from
# Returns:
#   none
#######################################
unsubscribe()
{
  load_subs

  # Convert to lowercase
  local -r streamerToUnsubscribeFrom="${1,,}"

  # Find index of streamer in .subscriptions[]
  local whileCounter=0

  local currentSubscription
  currentSubscription=$(jq -r ".subscriptions[${whileCounter}].streamer" "${CONFIG_FILE}")

  while [[ "${currentSubscription}" != "$streamerToUnsubscribeFrom" ]] && [[ "${currentSubscription}" != "null" ]]; do
    # Refresh data
    whileCounter=$(( whileCounter + 1 ))
    currentSubscription=$(jq -r ".subscriptions[${whileCounter}].streamer" "${CONFIG_FILE}")
  done

  # Check to make sure user is subscribed before unsubscribing
  if [[ ! $whileCounter -lt $(jq ".subscriptions | length" "${CONFIG_FILE}") ]]; then
    exit_script_on_failure "You aren't subscribed to ${streamerToUnsubscribeFrom}."
  fi

  # Remove subscription
  local -r tmpJson=$(jq "del(.subscriptions[${whileCounter}])" "${CONFIG_FILE}")
  printf "%s" "${tmpJson}" > "${CONFIG_FILE}"

  # Invalidate cache
  write_setting ".lastSubscriptionUpdate" "null"
}

#######################################
# Writes a setting value to the config file.
# Globals:
#   CONFIG_FILE
# Arguments:
#   $1: key
#   $2: value
# Returns:
#   none
#######################################
write_setting()
{
  local -r tmpJson=$(jq "$1 = \"$2\"" "${CONFIG_FILE}")
  printf "%s" "${tmpJson}" > "${CONFIG_FILE}"
}

# -----------------------------------------
# ---------------- Script -----------------
# -----------------------------------------

if [[ $# -eq 0 ]]; then
  print_help
  printf "%s" "${NC}" && exit 0
fi

# Parse flags. From:
# https://stackoverflow.com/questions/7069682/how-to-get-arguments-with-flags-in-bash/7069755#7069755
while [[ $# -gt 0 ]]; do
  case "$1" in
    -h|--help)
      print_help
      printf "%s" "${NC}" && exit 0
      break
      ;;
    -c|--check)
      check_twitch_streams
      printf "%s" "${NC}" && exit 0
      break
      ;;
    -g)
      shift
      if [[ $# -gt 0 ]]; then
        list_streamers_of_game "$1"
        printf "%s" "${NC}" && exit 0
      else
        exit_script_on_failure "No game specified."
      fi
      break
      ;;
    --get-streamers*)
      if [[ $# -gt 1 ]]; then
        shift
      fi
      if [[ $# -gt 0 ]]; then
        gameToCheck=$(printf "%s" "$1" | sed -e 's/^[^=]*=//g')
        list_streamers_of_game "${gameToCheck}"
      else
        exit_script_on_failure "No game specified."
      fi
      printf "%s" "${NC}" && exit 0
      break
      ;;
    -l|--toggle-colors)
      toggle_colors
      printf "%s" "${NC}" && exit 0
      break
      ;;
    -p)
      shift
      if [[ $# -gt 0 ]]; then
        change_player "$1"
        printf "%s" "${NC}" && exit 0
      else
        exit_script_on_failure "No media player specified."
      fi
      break
      ;;
    --change-player*)
      if [[ $# -gt 1 ]]; then
        shift
      fi
      if [[ $# -gt 0 ]]; then
        player=$(printf "%s" "$1" | sed -e 's/^[^=]*=//g')
        change_player "${player}"
      else
        exit_script_on_failure "No media player specified."
      fi
      printf "%s" "${NC}" && exit 0
      break
      ;;
    -q)
      shift
      if [[ $# -gt 0 ]]; then
        change_quality "$1"
        printf "%s" "${NC}" && exit 0
      else
        exit_script_on_failure "No quality specified."
      fi
      break
      ;;
    --change-quality*)
      if [[ $# -gt 1 ]]; then
        shift
      fi
      if [[ $# -gt 0 ]]; then
        quality=$(printf "%s" "$1" | sed -e 's/^[^=]*=//g')
        change_quality "${quality}"
      else
        exit_script_on_failure "No quality specified."
      fi
      printf "%s" "${NC}" && exit 0
      break
      ;;
    -s)
      shift
      if [[ $# -gt 0 ]]; then
        subscribe "$1"
        printf "%s" "${NC}" && exit 0
      else
        exit_script_on_failure "No streamer specified."
      fi
      break
      ;;
    --subscribe*)
      if [[ $# -gt 1 ]]; then
        shift
      fi
      if [[ $# -gt 0 ]]; then
        streamerToSubscribeTo=$(printf "%s" "$1" | sed -e 's/^[^=]*=//g')
        subscribe "${streamerToSubscribeTo}"
      else
        exit_script_on_failure "No streamer specified."
      fi
      printf "%s" "${NC}" && exit 0
      break
      ;;
    -t|--top)
      list_top
      printf "%s" "${NC}" && exit 0
      break
      ;;
    -u)
      shift
      if [[ $# -gt 0 ]]; then
        unsubscribe "$1"
        printf "%s" "${NC}" && exit 0
      else
        exit_script_on_failure "No streamer specified."
      fi
      break
      ;;
    --unsubscribe*)
      if [[ $# -gt 1 ]]; then
        shift
      fi
      if [[ $# -gt 0 ]]; then
        streamerToUnsubscribeFrom=$(printf "%s" "$1" | sed -e 's/^[^=]*=//g')
        unsubscribe "${streamerToUnsubscribeFrom}"
      else
        exit_script_on_failure "No streamer specified."
      fi
      printf "%s" "${NC}" && exit 0
      break
      ;;
    -v|--version)
      printf "wtwitch v%s\n" "${VERSION}"
      printf "Copyright (C) %s 2019-%s\n" "${CONTRIBUTORS}" "$(date +%Y)"
      printf "This is free software: you are free to change and redistribute it.\n"
      printf "There is NO WARRANTY, to the extent permitted by law.\n"
      printf "%s" "${NC}" && exit 0
      break
      ;;
    *)
      break
      ;;
  esac
done

load_config

# If quality="audio_only" OR debugging, do not open streamlink as a background process
if [[ "${userQuality}" == "audio_only" ]] || [[ "${DEBUGGING}" == "on" ]]; then
  stream "$1"
else
  stream "$1" &> /dev/null &
fi
