#!/usr/bin/env bash
#
# Description: Browse and watch Twitch without being tracked.
#
# Copyright (C) 2019-2020:
readonly CONTRIBUTORS="krathalan, nycko123, Léo Villeveygoux"
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

# -----------------------------------------
# -------------- Guidelines ---------------
# -----------------------------------------

# This script follows the Google Shell Style Guide:
# https://google.github.io/styleguide/shell.xml

# This script uses shellcheck: https://www.shellcheck.net/
# There are no "shellcheck disable=SCXXXX" lines in this script.

# Many functions in this script spawn subshell processes
trap "clean_up && kill 0" SIGINT

# See https://vaneyckt.io/posts/safer_bash_scripts_with_set_euxo_pipefail/
set -Eeuo pipefail

# -----------------------------------------
# ----------- Program variables -----------
# -----------------------------------------

# Script (self) information
readonly SCRIPT_NAME="${0##*/}"
readonly PROJECT_URL="https://git.sr.ht/~krathalan/wtwitch"
readonly VERSION="1.6.2"

# Subscription check cache
readonly CACHE_EXPIRY_TIME="60" # In seconds
readonly CACHE_FILE_DIRECTORY="${XDG_CACHE_HOME:-${HOME}/.cache}/${SCRIPT_NAME}"
readonly CACHE_OFFLINE_TEXT_FILE="${CACHE_FILE_DIRECTORY}/stream_offline.txt"
readonly CACHE_ONLINE_TEXT_FILE="${CACHE_FILE_DIRECTORY}/stream_online.txt"

# Used by list_streamers_of_game() and list_top()
readonly CACHE_MISC_TEXT_FILE="${CACHE_FILE_DIRECTORY}/stream_misc.txt"
# Used exclusively by list_top()
readonly CACHE_TOP_STREAMS_TEXT_FILE="${CACHE_FILE_DIRECTORY}/stream_top_streamers.txt"

# Used to reduce strain on Twitch API; see get_game_name()
readonly CACHE_GAME_ID_FILE="${CACHE_FILE_DIRECTORY}/gameids.json"

# Config
readonly CONFIG_FILE_DIRECTORY="${XDG_CONFIG_HOME:-${HOME}/.config}/${SCRIPT_NAME}"

readonly CONFIG_FILE="${CONFIG_FILE_DIRECTORY}/config.json"

# Used to calculate output string lengths; see check_twitch_streams_helper()
# and list_streamers_of_game_helper()
readonly TERMINAL_WIDTH="$(tput cols)"

# Twitch API information
# This API key is intended to be used for wtwitch only -- do not use this API
# key for any other reason!
readonly TWITCH_API_URL="https://api.twitch.tv"
readonly TWITCH_ID_URL="https://id.twitch.tv/oauth2/token"
readonly TWITCH_API_KEY="cotxsalhlctv8z572f7fant4b0sc3u"
readonly TWITCH_API_SECRET="gaofxvult280l3sbz8n6btvk5fdswp"

# Colors
GREEN="\e[1m\e[32m"
GREY="\e[90m"
LIGHTGREEN="\e[92m"
NC="\e[0m" # No color/turn off all tput attributes
ORANGE="\e[93m"
PURPLE="\e[95m"
RED="\e[1m\e[91m"
TURQOISE="\e[96m"

# Get beginning of $LANG for translations
WTWITCH_LANG="${LANG%_*}"

# -----------------------------------------
# ------------- Translations --------------
# -----------------------------------------

readonly TRANSLATIONS="$(cat <<EOF
{
  "change_player_not_found": {
    "en": "media player not found",
    "de": "Videospieler nicht gefunden",
    "es": "reproductor de vídeo no encontrado",
    "fr": "lecteur vidéo non trouvé"
  },
  "change_player_warning": {
    "en": "Warning",
    "de": "Warnung",
    "es": "Advertencia",
    "fr": "Attention"
  },
  "change_player_player": {
    "en": "player",
    "de": "Videospieler",
    "es": "reproductor",
    "fr": "lecteur"
  },
  "change_player_warning_text": {
    "en": "may not work properly with Streamlink",
    "de": "funktioniert möglicherweise nicht richtig mit Streamlink",
    "es": "puede no funcionar correctamente con Streamlink",
    "fr": "peut ne pas fonctionner correctement avec Streamlink"
  },
  "change_quality_error": {
    "en": "is not an acceptable quality. 1080p60, 720p60, 720p, 480p, 360p, 160p, best, worst, and audio_only are acceptable qualities. You can specify fallback qualities separated by a comma, e.g. \"720p,480p,worst\"",
    "de": "is not an acceptable quality. 1080p60, 720p60, 720p, 480p, 360p, 160p, best, worst, and audio_only are acceptable qualities. You can specify fallback qualities separated by a comma, e.g. \"720p,480p,worst\"",
    "es": "is not an acceptable quality. 1080p60, 720p60, 720p, 480p, 360p, 160p, best, worst, and audio_only are acceptable qualities. You can specify fallback qualities separated by a comma, e.g. \"720p,480p,worst\"",
    "fr": "n'est pas une qualité acceptable. 1080p60, 720p60, 720p, 480p, 360p, 160p, best, worst, et audio_only sont les qualités acceptables. Vous pouvez spécifier des qualités de repli séparées par des virgules, par exemple : \"720p,480p,worst\""
  },
  "check_online": {
    "en": "Live channels",
    "de": "Live Kanäle",
    "es": "Canales en directo",
    "fr": "Chaînes en direct"
  },
  "check_offline": {
    "en": "Offline",
    "de": "Offline",
    "es": "Desconectado",
    "fr": "Déconnecté"
  },
  "check_settings": {
    "en": "Settings",
    "de": "Einstellungen",
    "es": "Ajuste",
    "fr": "Configuration"
  },
  "check_player": {
    "en": "Player set to",
    "de": "Videospieler eingestellt auf",
    "es": "Reproductor de vídeo configurado en",
    "fr": "Lecteur configuré à"
  },
  "check_quality": {
    "en": "Quality set to",
    "de": "Qualität eingestellt auf",
    "es": "Calidad configurado en",
    "fr": "Qualité configurée à"
  },
  "top_games": {
    "en": "Top games",
    "de": "Beliebteste Spiele",
    "es": "Juegos más populares",
    "fr": "Jeux les plus populaires"
  },
  "top_streams": {
    "en": "Top channels",
    "de": "Beliebteste Kanäle",
    "es": "Canales más populares",
    "fr": "Chaînes les plus populaires"
  },
  "viewers": {
    "en": "viewers",
    "de": "Beobachter",
    "es": "espectadores",
    "fr": "spectateurs"
  },
  "channels": {
    "en": "channels",
    "de": "Kanäle",
    "es": "Canales de",
    "fr": "Chaînes de"
  },
  "no_channels": {
    "en": "No one is streaming",
    "de": "No one is streaming",
    "es": "No one is streaming",
    "fr": "Personne n'est en direct"
  },
  "error": {
    "en": "Error",
    "de": "Fehler",
    "es": "Error",
    "fr": "Érreur"
  },
  "exiting": {
    "en": "Exiting",
    "de": "Verlassen von",
    "es": "Saliendo de",
    "fr": "Fermeture de"
  },
  "print_help": {
    "en": "View the man page at",
    "de": "View the man page at",
    "es": "View the man page at",
    "fr": "Voir le manuel à"
  },
  "stream_failure_player_one": {
    "en": "Player",
    "de": "Videospieler",
    "es": "Reproductor",
    "fr": "Lecteur"
  },
  "stream_failure_player_two": {
    "en": "not found",
    "de": "nicht gefunden",
    "es": "no encontrado",
    "fr": "non trouvé"
  },
  "stream_failure_offline_one": {
    "en": "Streamer",
    "de": "Streamer",
    "es": "Streamer",
    "fr": "La chaîne"
  },
  "stream_failure_offline_two": {
    "en": "is not online",
    "de": "is not online",
    "es": "is not online",
    "fr": "n'est pas en ligne"
  },
  "stream_failure_quality": {
    "en": "stream does not support quality",
    "de": "stream does not support quality",
    "es": "stream does not support quality",
    "fr": "n'est pas diffusé dans la qualité"
  },
  "stream_failure_one": {
    "en": "watching",
    "de": "Beobachtung von",
    "es": "viendo",
    "fr": "le visionnage de"
  },
  "stream_failure_two": {
    "en": "failed",
    "de": "fehlgeschlagen",
    "es": "falló",
    "fr": "a échoué"
  },
  "stream_watching": {
    "en": "Watching",
    "de": "beobachten",
    "es": "Viendo",
    "fr": "Visionnage de"
  },
  "stream_on_twitch": {
    "en": "on Twitch",
    "de": "auf Twitch",
    "es": "en Twitch",
    "fr": "sur Twitch"
  },
  "subscribe_failure": {
    "en": "You are already subscribed to",
    "de": "You are already subscribed to",
    "es": "You are already subscribed to",
    "fr": "Vous êtes déjà abonné à"
  },
  "unsubscribe_failure": {
    "en": "You are not subscribed to",
    "de": "You are not subscribed to",
    "es": "You are not subscribed to",
    "fr": "Vous n'êtes pas abonné à"
  },
  "colors_off": {
    "en": "Turned colors off",
    "de": "Abgeschaltete Farben",
    "es": "Apagó los colores",
    "fr": "Couleurs désactivées"
  },
  "colors_on": {
    "en": "Turned colors on",
    "de": "Eingeschaltete Farben",
    "es": "Encendió los colores",
    "fr": "Couleurs activées"
  },
  "flags_no_game": {
    "en": "No game specified",
    "de": "Kein Spiel angegeben",
    "es": "No se especifica ningún juego",
    "fr": "Pas de jeu spécifié"
  },
  "flags_no_player": {
    "en": "No player specified",
    "de": "Kein Videospeiler angegeben",
    "es": "No se especifica el reproductor de vídeo",
    "fr": "Pas de lecteur vidéo spécifié"
  },
  "flags_no_quality": {
    "en": "No quality specified",
    "de": "Kein Qualität angegeben",
    "es": "No se especifica la calidad",
    "fr": "Pas de qualité spécifiée"
  },
  "flags_no_streamer": {
    "en": "No streamer specified",
    "de": "Kein Kanal angegeben",
    "es": "No se especifica ningún canal",
    "fr": "Pas de chaîne spécifiée"
  },
  "no_subs": {
    "en": "You aren't subscribed to any channels",
    "de": "You aren't subscribed to any channels",
    "es": "You aren't subscribed to any channels",
    "fr": "Vous n'êtes abonné à aucune chaîne"
  }
}
EOF
)"

# -----------------------------------------
# ------- Pre-script: check & load --------
# -----------------------------------------

# Check files
# Create config file if it doesnt exist
if [[ ! -f "${CONFIG_FILE}" ]]; then
  if [[ ! -d "${CONFIG_FILE_DIRECTORY}" ]]; then
    mkdir -p "${CONFIG_FILE_DIRECTORY}"
  fi

  # Default config
  printf "{\"player\": \"mpv\",\"quality\": \"best\",\"colors\": \"true\",\"subscriptions\": []}" > "${CONFIG_FILE}"
fi

# Create cache folder if it doesn't exist
if [[ ! -d "${CACHE_FILE_DIRECTORY}" ]]; then
  mkdir -p "${CACHE_FILE_DIRECTORY}"
fi

# Create gameids cache file
if [[ ! -f "${CACHE_GAME_ID_FILE}" ]]; then
  printf "{\"data\": []}" > "${CACHE_GAME_ID_FILE}"
fi

# Load settings
read -r apiToken apiTokenExpiry useColors userPlayer userQuality \
<<< "$(jq -r ".apiToken, .apiTokenExpiry, .colors, .player, .quality" "${CONFIG_FILE}" | tr "\n" " ")"

# Deactivate colors if useColors is false
if [[ "${useColors}" == "false" ]]; then
  GREEN="${NC}"
  GREY="${NC}"
  LIGHTGREEN="${NC}"
  ORANGE="${NC}"
  PURPLE="${NC}"
  RED="${NC}"
  TURQOISE="${NC}"
fi

# Debugging
if [[ "$*" == *"-d"* ]] || [[ "$*" == *"--debug"* ]]; then
  # Avoid subshells, print full wget output, and more behavioral changes
  readonly DEBUGGING="on"
  readonly wgetFlags=""

  # Print log information
  readonly _dashes="-----------------------------------------------------------"

  if pacman -Q wtwitch &> /dev/null; then
    readonly _packageinfo="installed via pacman"
  else
    readonly _packageinfo="script or unknown"
  fi

  printf "Starting wtwitch debug log\nPackage: %s\nVersions: wtwitch-%s %s\nDate: %s\n\nCommand: wtwitch %s\n\nConfig file:\n\n%s\n\n%s\nBegin log\n%s\n\n" \
  "${_packageinfo}" "${VERSION}" "$(jq --version) $(streamlink --version)" "$(date)" "$*" "$(jq -r "." "${CONFIG_FILE}")" "${_dashes}" "${_dashes}"

  # Print all commands
  set -x
else
  readonly DEBUGGING="off"
  readonly wgetFlags="--quiet"
fi

# Why is TITLE_CHARACTERS=11? Because that's how many characters will always
# be present in a printed line; ergo they must be subtracted from the total
# terminal width to get the effective maximum stream title length.
TITLE_CHARACTERS=11

# Add language-specific ".viewer" character count to TITLE_CHARACTERS
case "${WTWITCH_LANG}" in
  "de")
    # Beobachter=10
    TITLE_CHARACTERS="$(( TITLE_CHARACTERS + 10 ))"
    ;;
  "es")
    # espectadores=12
    TITLE_CHARACTERS="$(( TITLE_CHARACTERS + 12 ))"
    ;;
  "fr")
    # spectateurs=11
    TITLE_CHARACTERS="$(( TITLE_CHARACTERS + 11 ))"
    ;;
  *)
    # Default to English if language isn't supported
    WTWITCH_LANG="en"
    # viewers=7
    TITLE_CHARACTERS="$(( TITLE_CHARACTERS + 7 ))"
    ;;
esac

# -----------------------------------------
# --------------- API Token ---------------
# -----------------------------------------

#######################################
# Writes a setting value to the config file.
# Globals:
#   CONFIG_FILE
# Arguments:
#   $1: key
#   $2: value
# Returns:
#   none
#######################################
write_setting()
{
  local -r tmpJson="$(jq "$1 = \"$2\"" "${CONFIG_FILE}")"
  printf "%s" "${tmpJson}" > "${CONFIG_FILE}"
}

#######################################
# Gets an OAuth token for the Twitch API.
# Globals:
#   TWITCH_API_KEY
#   TWITCH_API_SECRET
# Arguments:
#   none
# Returns:
#   none
#######################################
download_token()
{
  # Get token
  local -r tmpJson="$(wget "${wgetFlags}" --output-document=- --post-data="client_id=${TWITCH_API_KEY}&client_secret=${TWITCH_API_SECRET}&grant_type=client_credentials" "${TWITCH_ID_URL}")"

  local -r newToken="$(jq -r ".access_token" <<< "${tmpJson}")"

  # Update in-memory api token
  apiToken="${newToken}"

  # Add token to config and update token expiration date
  write_setting ".apiToken" "${newToken}"
  write_setting ".apiTokenExpiry" "$(LANG=C date -d tomorrow +%s)"
}

# If the API token is null (e.g. there is no token),
# OR if API token is expired
if [[ "${apiToken}" == "null" ]] || [[ "$(LANG=C date +%s)" -gt "${apiTokenExpiry}" ]]; then
  download_token
fi

# -----------------------------------------
# --------------- Functions ---------------
# -----------------------------------------

#######################################
# Extracts an argument from a --flag=argument.
# Globals:
#   none
# Arguments:
#   $1: full --flag=argument string
# Returns:
#   extracted argument
#######################################
extract_argument()
{
  # From:
  # https://stackoverflow.com/questions/7069682/how-to-get-arguments-with-flags-in-bash/7069755#7069755
  # Updated to use variable search replace instead of sed
  printf "%s" "${1#--*[ =]}"
}

#######################################
# Changes the default player in $CONFIG_FILE that gets passed to streamlink.
# Globals:
#   Colors: ORANGE, NC
#   useColors
# Arguments:
#   $1: player to set as default
# Returns:
#   none
#######################################
change_player()
{
  local -r workingPlayers=("gnome-mpv" "mpv" "mplayer" "vlc")
  local passedCheckMarker="false"

  # Get localized strings
  mapfile -t localizedStrings <<< "$(jq -r ".change_player_not_found.${WTWITCH_LANG}, .change_player_warning.${WTWITCH_LANG}, .change_player_player.${WTWITCH_LANG}, .change_player_warning_text.${WTWITCH_LANG}" <<< "${TRANSLATIONS}")"

  # Convert user input to lowercase
  local -r playerName="${1,,}"

  # Check to make sure user has input player actually installed
  if [[ ! -x "$(command -v "${playerName}")" ]]; then
    exit_script_on_failure "${localizedStrings[0]}: ${playerName}"
  fi

  # Check against known working players
  for i in "${workingPlayers[@]}"; do
    if [[ "${playerName}" == "${i}" ]]; then
      passedCheckMarker="true"
    fi
  done

  if [[ "${passedCheckMarker}" != "true" ]]; then
    printf "\n %b%s%b: %s %s %s.\n" "${ORANGE}" "${localizedStrings[1]}" "${NC}" "${localizedStrings[2]}" "${playerName}" "${localizedStrings[3]}"
  fi

  write_setting ".player" "${playerName}"
}

#######################################
# Changes the default quality in $CONFIG_FILE that gets passed to streamlink.
# Globals:
#   none
# Arguments:
#   $1: quality to set as default, e.g. "1080p60,720p60,best"
# Returns:
#   none
#######################################
change_quality()
{
  local -r acceptableQualities=("audio_only" "worst" "160p" "360p" "480p" "720p" "720p60" "1080p60" "best")
  local passedCheckMarkerArray=()

  # Convert user input to lowercase
  local -r specifiedQuality="${1,,}"

  # User may try and enter fallback qualities; code should account for this
  IFS=',' read -r -a qualityArray <<< "$specifiedQuality"

  # For each quality the user has specified
  for i in "${qualityArray[@]}"; do
    # Check to make sure it's an acceptable quality
    for j in "${acceptableQualities[@]}"; do
      if [[ "${i}" == "${j}" ]]; then
        passedCheckMarkerArray+=("true")
      fi
    done
  done

  # Make sure there are an equal number of "true" elements in passedCheckMarkers as there are qualities in specifiedQuality
  if [[ ${#qualityArray[@]} -eq ${#passedCheckMarkerArray[@]} ]]; then
    write_setting ".quality" "${specifiedQuality}"
  else
    exit_script_on_failure "${specifiedQuality} $(jq -r ".change_quality_error.${WTWITCH_LANG}" <<< "${TRANSLATIONS}")."
  fi
}

#######################################
# Checks to see which subscribed Twitch streams are online and prints the user's settings.
# Globals:
#   CACHE_EXPIRY_TIME
#   CACHE_OFFLINE_TEXT_FILE
#   CACHE_ONLINE_TEXT_FILE
#   CONFIG_FILE
#   DEBUGGING
#   userPlayer
#   userQuality
#   userSubscriptions
# Arguments:
#   none
# Returns:
#   none
#######################################
check_twitch_streams()
{
  # Get subscriptions
  mapfile -t userSubscriptions <<< "$(jq -r ".subscriptions[].streamer" "${CONFIG_FILE}")"

  # Get localized strings
  mapfile -t localizedStrings <<< "$(jq -r ".check_online.${WTWITCH_LANG}, .check_offline.${WTWITCH_LANG}, .check_settings.${WTWITCH_LANG}, .check_player.${WTWITCH_LANG}, .check_quality.${WTWITCH_LANG}, .no_subs.${WTWITCH_LANG}" <<< "${TRANSLATIONS}")"

  if [[ -z "${userSubscriptions[*]}" ]]; then
    printf "\n %s\n" "${localizedStrings[5]}"
  else
    printf "\n %s:" "${localizedStrings[0]}"

    # Check cache expiry time
    local dateDiff="0"
    local lastSubscriptionUpdate
    lastSubscriptionUpdate="$(jq -r ".lastSubscriptionUpdate" "${CONFIG_FILE}")"

    # Check for older (e.g. "Sun Nov  3 14:54:55 PST 2019") style lastSubscriptionUpdate
    if ! [[ "${lastSubscriptionUpdate}" =~ ^[0-9]+$ ]] ; then
      lastSubscriptionUpdate=0
    fi

    if [[ "${lastSubscriptionUpdate}" != "null" ]]; then
      local -r currentDate="$(LANG=C date +%s)"
      dateDiff="$(( currentDate - lastSubscriptionUpdate ))"
    fi

    # If the last subsription update is null (e.g. the subscriptions have never been checked), OR
    # if the time between now and the last subscription update is greater than the cache expiry time, OR
    # if either of the cache files do NOT exist yet
    if  [[ "${lastSubscriptionUpdate}" == "null" ]] || [[ $dateDiff -gt $CACHE_EXPIRY_TIME ]] \
    || [[ ! -f "${CACHE_ONLINE_TEXT_FILE}" ]] || [[ ! -f "${CACHE_OFFLINE_TEXT_FILE}" ]]; then
      # Remove old cache files
      clean_up

      # Ensure that both CACHE_ONLINE_TEXT_FILE and CACHE_OFFLINE_TEXT_FILE get written to; sometimes all streamers are online or offline
      touch "${CACHE_ONLINE_TEXT_FILE}" "${CACHE_OFFLINE_TEXT_FILE}"

      # Build inital request URL
      local initialRequestURL="${TWITCH_API_URL}/helix/streams?"

      for stream in "${userSubscriptions[@]}"; do
        initialRequestURL+="user_login=${stream}&"
      done

      # Get data of all online streamers (sans game names)
      local -r allStreamerJson="$(download_file "${initialRequestURL}")"

      # Figure out offline streamers in background
      if [[ "${DEBUGGING}" == "on" ]]; then
        get_offline_streams "${allStreamerJson}"
      else
        get_offline_streams "${allStreamerJson}" &
      fi

      # Pass each streamer json data to check_twitch_streams_helper to parse,
      # get game name for, and print
      local whileCounter=0

      local streamerToProcess=""
      streamerToProcess="$(jq -r ".data[${whileCounter}]" <<< "${allStreamerJson}")"

      while [[ "${streamerToProcess}" != "null" ]]; do
        # Don't use subshells when debugging is on
        if [[ "${DEBUGGING}" == "on" ]]; then
          check_twitch_streams_helper "${streamerToProcess}"
        else
          check_twitch_streams_helper "${streamerToProcess}" &
        fi

        # Refresh data
        whileCounter="$(( whileCounter + 1 ))"
        streamerToProcess="$(jq -r ".data[${whileCounter}]" <<< "${allStreamerJson}")"
      done

      # Wait for all background processes, offline and online, to finish
      wait

      # Update lastSubscriptionUpdate time
      write_setting ".lastSubscriptionUpdate" "$(LANG=C date +%s)"
    fi

    printf "\n"

    sort "${CACHE_ONLINE_TEXT_FILE}" 2> /dev/null

    printf "\n %s:\n" "${localizedStrings[1]}"

    sort "${CACHE_OFFLINE_TEXT_FILE}" 2> /dev/null
  fi

  # Print settings
  printf "\n %s:\n   %s %s\n   %s %s\n" "${localizedStrings[2]}" "${localizedStrings[3]}" "${userPlayer}" "${localizedStrings[4]}" "${userQuality}"
}

#######################################
# Used by check_twitch_streams to figure out the streamers that are offline.
# Globals:
#   DEBUGGING
#   userSubscriptions
# Arguments:
#   $1: "${allStreamerJson}" to compare with user subscriptions
# Returns:
#   none
#######################################
get_offline_streams()
{
  for streamerName in "${userSubscriptions[@]}"; do
    # Don't use subshells if debugging is on
    if [[ "${DEBUGGING}" == "on" ]]; then
      get_offline_streams_helper "${streamerName}" "$1"
    else
      get_offline_streams_helper "${streamerName}" "$1" &
    fi
  done
}

#######################################
# Used by get_offline_streams to figure out the streamers that are offline.
# Globals:
#   Colors: NC, GREY
#   CACHE_OFFLINE_TEXT_FILE
# Arguments:
#   $1: streamer to check
#   $2: "${allStreamerJson}" to compare with streamer
# Returns:
#   none
#######################################
get_offline_streams_helper()
{
  if ! grep -qi "$1" <<< "$2"; then
    printf "   %b%s%b\n" "${GREY}" "$1" "${NC}" >> "${CACHE_OFFLINE_TEXT_FILE}"
  fi
}

#######################################
# Returns the game name for a specified game ID. Attempts to get game name from
# cache, but if game ID not present, retrieves it from the Twitch API.
# Globals:
#   CACHE_GAME_ID_FILE
# Arguments:
#   $1: game ID to get game name of
# Returns:
#   game name of specified ID
#######################################
get_game_name()
{
  # Add "id" prefix as jq does not accept numerical identifiers
  local -r gameID="id$1"

  # Attempt to extract game name from cached game ids
  local gameName
  gameName="$(jq -r ".data | add | .${gameID}" "${CACHE_GAME_ID_FILE}")"

  # If game id not cached, fetch from Twitch API
  if [[ "${gameName}" == "" ]] || [[ "${gameName}" == "null" ]]; then
    local tmpJson
    tmpJson="$(download_file "${TWITCH_API_URL}/helix/games?id=$1")"
    gameName="$(jq -r ".data[0].name" <<< "${tmpJson}")"

    # Guard against wiping gameid cache
    # This will happen when tmpJson is null as the result of too many Twitch
    # API queries in a short amount of time
    if [[ "${gameName}" == "" ]] || [[ "${gameName}" == "null" ]]; then
      exit_script_on_failure "Twitch API rate limit reached"
    fi

    # Cache result for future reference
    tmpJson="$(jq ".data[.data | length] |= . + {\"${gameID}\":\"${gameName}\"}" "${CACHE_GAME_ID_FILE}")"
    printf "%s" "${tmpJson}" > "${CACHE_GAME_ID_FILE}"
  fi

  printf "%s" "${gameName}"
}

#######################################
# Used by check_twitch_streams to facilitate multi-process fetching and parsing of json files.
# Globals:
#   Colors: LIGHTGREEN, NC, ORANGE, GREY
#   CACHE_OFFLINE_TEXT_FILE
#   CACHE_ONLINE_TEXT_FILE
#   TERMINAL_WIDTH
#   TITLE_CHARACTERS
#   TWITCH_API_URL
# Arguments:
#   none
# Returns:
#   none
#######################################
check_twitch_streams_helper()
{
  mapfile -t streamerData <<< "$(jq -r ".user_name, .game_id, .title" <<< "$1")"

  # Get stream game name from game ID
  local streamGame
  streamGame="$(get_game_name "${streamerData[1]}")"

  # Get streamer-set stream name
  # Truncate stream name if necessary; some streamers have stream titles longer
  # than the terminal width and cause ugly output
  local -r maxTitleLength="$(( TERMINAL_WIDTH - TITLE_CHARACTERS - ${#streamGame} - ${#streamerData[0]} + 7))"

  local streamName="${streamerData[2]:0:${maxTitleLength}}"

  if [[ "${#streamName}" == "${maxTitleLength}" ]]; then
    streamName+="…"
  fi

  printf "   %b%s%b: %s %b(%s)%b\n" "${LIGHTGREEN}" "${streamerData[0]}" "${NC}" "${streamName}" "${ORANGE}" "${streamGame}" "${NC}" >> "${CACHE_ONLINE_TEXT_FILE}"
}

#######################################
# Cleans up temporary file(s).
# Globals:
#   CACHE_ONLINE_TEXT_FILE
#   CACHE_OFFLINE_TEXT_FILE
# Arguments:
#   none
# Returns:
#   none
#######################################
clean_up()
{
  # Clean up
  rm -f "${CACHE_ONLINE_TEXT_FILE}" "${CACHE_OFFLINE_TEXT_FILE}" "${CACHE_MISC_TEXT_FILE}" "${CACHE_TOP_STREAMS_TEXT_FILE}"
}

#######################################
# Downloads a file quietly using wget and passes the TWITCH_API_KEY as a header to the server. Returns the downloaded file.
# Globals:
#   apiToken
#   TWITCH_API_KEY
# Arguments:
#   $1: file to download
# Returns:
#   downloaded file
#######################################
download_file()
{
  wget "${wgetFlags}" --output-document=- --header="Client-ID: ${TWITCH_API_KEY}" \
  --header="Authorization: Bearer ${apiToken}" "$1"
}

#######################################
# Prints passed error message before premature exit. Prints everything to >&2 (STDERR).
# Globals:
#   Colors: RED, NC
#   SCRIPT_NAME
# Arguments:
#   $1: error message to print
# Returns:
#   none
#######################################
exit_script_on_failure()
{
  mapfile -t localizedStrings <<< "$(jq -r ".error.${WTWITCH_LANG}, .exiting.${WTWITCH_LANG}" <<< "${TRANSLATIONS}")"

  if [[ $# -gt 0 ]]; then
    printf "\n %b%s%b: %s\n\n %s %s.\n%b" "${RED}" "${localizedStrings[0]}" "${NC}" "$1" "${localizedStrings[1]}" "${SCRIPT_NAME}" "${NC}" >&2
  fi

  clean_up
  exit 1
}

#######################################
# Lists the top streamers for a specified game.
# Globals:
#   CACHE_MISC_TEXT_FILE
#   DEBUGGING
#   TWITCH_API_URL
# Arguments:
#   $1: game to list top streamers of
# Returns:
#   none
#######################################
list_streamers_of_game()
{
  mapfile -t localizedStrings <<< "$(jq -r ".channels.${WTWITCH_LANG}, .no_channels.${WTWITCH_LANG}" <<< "${TRANSLATIONS}")"

  # Spanish has a different structure
  if [[ "${WTWITCH_LANG}" == "es" ]] || [[ "${WTWITCH_LANG}" == "fr" ]]; then
    printf "\n %s %s:\n" "${localizedStrings[0]}" "$1"
  else
    printf "\n %s %s:\n" "$1" "${localizedStrings[0]}"
  fi

  # Replace spaces in game name with %20 for URL
  local -r gameName=${1// /%20}

  # Get game_id
  local twitchJson
  twitchJson="$(download_file "${TWITCH_API_URL}/helix/games?name=${gameName}")"

  local -r gameID="$(jq -r ".data[0].id" <<< "${twitchJson}")"

  # Get streamers
  twitchJson="$(download_file "${TWITCH_API_URL}/helix/streams?game_id=${gameID}")"

  # Remove old cache files
  clean_up

  local whileCounter=0

  local streamerName=""
  streamerName="$(jq -r ".data[${whileCounter}].user_name" <<< "${twitchJson}")"

  while [[ "${streamerName}" != "null" ]]; do
    # Don't use subshells when debugging is on
    if [[ "${DEBUGGING}" == "on" ]]; then
      print_stream_info "${whileCounter}" "${twitchJson}" "${streamerName}" "${CACHE_MISC_TEXT_FILE}"
    else
      print_stream_info "${whileCounter}" "${twitchJson}" "${streamerName}" "${CACHE_MISC_TEXT_FILE}" &
    fi

    # Refresh data
    whileCounter="$(( whileCounter + 1 ))"
    streamerName="$(jq -r ".data[${whileCounter}].user_name" <<< "${twitchJson}")"
  done

  wait

  if [[ -f "${CACHE_MISC_TEXT_FILE}" ]]; then
    cat "${CACHE_MISC_TEXT_FILE}"
  else
    printf " %s %s.\n" "${localizedStrings[1]}" "$1"
  fi
}

#######################################
# Facilitates multi-process parsing of json files.
# Globals:
#   Colors: TURQOISE, NC, ORANGE
#   CACHE_MISC_TEXT_FILE
#   TERMINAL_WIDTH
#   TITLE_CHARACTERS
# Arguments:
#   $1: index of streamer to print info of
#   $2: json file containing streamer data
#   $3: name of streamer
#   $4: file to print to
#   $5: if this argument exists, print game of stream
# Returns:
#   none
#######################################
print_stream_info()
{
  mapfile -t streamerData <<< "$(jq -r ".data[$1].viewer_count, .data[$1].game_id, .data[$1].title" <<< "$2")"

  # If streamer data is empty, exit
  if [ "${streamerData[1]:-x}" = "x" ]; then
    exit
  fi

  # Get streamer-set stream name
  local streamName=""

  # Add game name to final string if $5 is present
  local additionalText=""
  if [[ "$*" == *"--print-game"* ]]; then
    additionalText="$(get_game_name "${streamerData[1]}"), "
  fi

  # Truncate stream name if necessary; some streamers have stream titles longer
  # than the terminal width and cause ugly output
  local -r maxTitleLength="$(( TERMINAL_WIDTH - TITLE_CHARACTERS - ${#3} - ${#additionalText} - ${#streamerData[0]} ))"

  local streamName="${streamerData[2]:0:${maxTitleLength}}"

  if [[ "${#streamName}" == "${maxTitleLength}" ]]; then
    streamName+="…"
  fi

  printf "   %b%s%b: %s %b(%s%s %s)%b\n" "${TURQOISE}" "$3" "${NC}" "${streamName}" "${ORANGE}" "${additionalText}" "${streamerData[0]}" "$(jq -r ".viewers.${WTWITCH_LANG}" <<< "${TRANSLATIONS}")" "${NC}" >> "$4"
}

#######################################
# Lists the top games and streamers on Twitch.
# Globals:
#   Colors: PURPLE, NC
#   CACHE_MISC_TEXT_FILE
#   CACHE_TOP_STREAMS_TEXT_FILE
#   DEBUGGING
#   TWITCH_API_URL
#   useColors
# Arguments:
#   none
# Returns:
#   none
#######################################
list_top()
{
  mapfile -t localizedStrings <<< "$(jq -r ".top_games.${WTWITCH_LANG}, .top_streams.${WTWITCH_LANG}" <<< "${TRANSLATIONS}")"

  printf "\n %s:\n" "${localizedStrings[0]}"

  # Remove old cache files
  clean_up

  # Start figuring out top streamers - don't use subshells when debugging is on
  if [[ "${DEBUGGING}" == "on" ]]; then
    list_top_streams
  else
    list_top_streams &
  fi

  # Figure out top games in foreground
  local -r topGamesJson="$(download_file "${TWITCH_API_URL}/helix/games/top")"

  local whileCounter=0

  local gameName=""
  gameName="$(jq -r ".data[${whileCounter}].name" <<< "${topGamesJson}")"

  while [[ "${gameName}" != "null" ]]; do
    printf "   %s. %b%s%b\n" $(( whileCounter + 1 )) "${PURPLE}" "${gameName}" "${NC}" >> "${CACHE_MISC_TEXT_FILE}"

    # Refresh data
    whileCounter="$(( whileCounter + 1 ))"
    gameName="$(jq -r ".data[${whileCounter}].name" <<< "${topGamesJson}")"
  done

  # Wait for list_top_streams() to finish
  wait

  cat "${CACHE_MISC_TEXT_FILE}"

  printf "\n %s:\n" "${localizedStrings[1]}"
  cat "${CACHE_TOP_STREAMS_TEXT_FILE}"
}

#######################################
# Lists the top streams on Twitch.
# Globals:
#   CACHE_TOP_STREAMS_TEXT_FILE
#   DEBUGGING
#   TWITCH_API_URL
# Arguments:
#   none
# Returns:
#   none
#######################################
list_top_streams()
{
  local -r topStreamsJson="$(download_file "${TWITCH_API_URL}/helix/streams?first=20")"

  local whileCounter=0

  local streamerName=""
  streamerName="$(jq -r ".data[${whileCounter}].user_name" <<< "${topStreamsJson}")"

  while [[ "${streamerName}" != "null" ]]; do
    # Don't use subshells when debugging is on
    if [[ "${DEBUGGING}" == "on" ]]; then
      print_stream_info "${whileCounter}" "${topStreamsJson}" "${streamerName}" "${CACHE_TOP_STREAMS_TEXT_FILE}" --print-game
    else
      print_stream_info "${whileCounter}" "${topStreamsJson}" "${streamerName}" "${CACHE_TOP_STREAMS_TEXT_FILE}" --print-game &
    fi

    # Refresh data
    whileCounter="$(( whileCounter + 1 ))"
    streamerName="$(jq -r ".data[${whileCounter}].user_name" <<< "${topStreamsJson}")"
  done

  wait
}

#######################################
# Prints information about how to use this script.
# Globals:
#   PROJECT_URL
# Arguments:
#   none
# Returns:
#   none
#######################################
print_help()
{
  man wtwitch || exit_script_on_failure "$(jq -r ".print_help.${WTWITCH_LANG}" <<< "${TRANSLATIONS}") ${PROJECT_URL}/tree/${VERSION}/wtwitch.1.scd"
}

#######################################
# Opens a stream with Streamlink.
# Globals:
#   TWITCH_API_URL
#   userPlayer
#   userQuality
# Arguments:
#   $1: name of streamer to watch
# Returns:
#   none
#######################################
stream()
{
  # Get localized strings
  mapfile -t localizedStrings <<< "$(jq -r ".stream_failure_player_one.${WTWITCH_LANG}, .stream_failure_player_two.${WTWITCH_LANG}, .stream_failure_offline_one.${WTWITCH_LANG}, .stream_failure_offline_two.${WTWITCH_LANG}, .stream_failure_quality.${WTWITCH_LANG}, .stream_watching.${WTWITCH_LANG}, .stream_on_twitch.${WTWITCH_LANG}" <<< "${TRANSLATIONS}")"

  # Use VLC as backup player if mpv is not installed
  if [[ ! -x "$(command -v "${userPlayer}")" ]]; then
    if [[ -x "$(command -v "vlc")" ]]; then
      userPlayer="vlc"
    else
      stream_failure_notify "$1" "${localizedStrings[0]} ${userPlayer} ${localizedStrings[1]}."
    fi
  fi

  # Check to make sure streamer is online
  # Get current info of streamer
  local -r streamerJson="$(download_file "${TWITCH_API_URL}/helix/streams?user_login=$1")"

  if [[ "$(jq -r ".data[0].type" <<< "${streamerJson}")" == "null" ]]; then
    stream_failure_notify "$1" "${localizedStrings[2]} $1 ${localizedStrings[3]}."
  fi

  # If using mpv: add window title, enable hardware dec, and use wayland if possible
  if [[ "${userPlayer}" == "mpv" ]]; then
    userPlayer+=" --hwdec=auto"

    if [[ $(pgrep wayland) || $(pgrep sway) ]]; then
      userPlayer+=" --gpu-context=wayland"
    fi

    if [[ "${WTWITCH_LANG}" == "de" ]]; then
      mpvWindowTitle="$1 ${localizedStrings[6]} ${localizedStrings[5]}"
    else
      mpvWindowTitle="${localizedStrings[5]} $1 ${localizedStrings[6]}"
    fi

    streamlink -p "${userPlayer}" --title "${mpvWindowTitle} (\\\${{video-params/h}}p \\\${{estimated-vf-fps}}fps)" --twitch-disable-ads "https://www.twitch.tv/$1" "${userQuality}" || stream_failure_notify "$1" "$1's ${localizedStrings[4]} ${userQuality}."
  else
    streamlink -p "${userPlayer}" --twitch-disable-ads "https://www.twitch.tv/$1" "${userQuality}" || stream_failure_notify "$1" "$1's ${localizedStrings[4]} ${userQuality}."
  fi
}

#######################################
# Notifies the user if streaming failed.
# Globals:
#   none
# Arguments:
#   $1: name of streamer
#   $2: error message to print
# Returns:
#   none
#######################################
stream_failure_notify()
{
  mapfile -t localizedStrings <<< "$(jq -r ".stream_failure_one.${WTWITCH_LANG}, .stream_failure_two.${WTWITCH_LANG}" <<< "${TRANSLATIONS}")"

  notify-send -i "gnome-twitch" "Wtwitch: ${localizedStrings[0]} $1 ${localizedStrings[1]}" "$2"
  exit_script_on_failure
}

#######################################
# Subscribes to a specific streamer.
# Globals:
#   CONFIG_FILE
# Arguments:
#   $1: streamer to subscribe to
# Returns:
#   none
#######################################
subscribe()
{
  mapfile -t userSubscriptions <<< "$(jq -r ".subscriptions[].streamer" "${CONFIG_FILE}")"

  # Convert to lowercase
  local -r streamerToSubscribeTo="${1,,}"

  # Check to make sure user isn't already subscribed
  if [[ ${#userSubscriptions[@]} -gt 0 ]]; then
    local whileCounter=0

    local currentSubscription
    currentSubscription="${userSubscriptions[${whileCounter}]}"

    while [[ ${whileCounter} -lt ${#userSubscriptions[@]} ]] && [[ "${currentSubscription}" != "${streamerToSubscribeTo}" ]]; do
      # Refresh data
      currentSubscription="${userSubscriptions[${whileCounter}]}"
      whileCounter="$(( whileCounter + 1))"
    done

    if [[ "${currentSubscription}" == "${streamerToSubscribeTo}" ]]; then
      exit_script_on_failure "$(jq -r ".subscribe_failure.${WTWITCH_LANG}" <<< "${TRANSLATIONS}") ${streamerToSubscribeTo}."
    fi
  fi

  # Add subscription (can't use write_setting here due to unique jq syntax)
  local -r tmpJson="$(jq ".subscriptions[.subscriptions | length] |= . + {\"streamer\":\"$streamerToSubscribeTo\"}" "${CONFIG_FILE}")"
  printf "%s" "${tmpJson}" > "${CONFIG_FILE}"

  # Invalidate cache
  write_setting ".lastSubscriptionUpdate" "null"
}

#######################################
# Changes the useColor value in $CONFIG_FILE that determines if wtwitch output is colorful.
# Globals:
#   Colors: GREEN, NC
#   useColors
# Arguments:
#   none
# Returns:
#   none
#######################################
toggle_colors()
{
  # Reverse "colors" value
  if [[ "${useColors}" == "true" ]]; then
    # "Empty" green
    GREEN="${NC}"

    write_setting ".colors" "false"
    local -r toPrint="$(jq -r ".colors_off.${WTWITCH_LANG}" <<< "${TRANSLATIONS}")"
  else
    # "Re-fill" green from empty
    GREEN="$(tput bold && tput setaf 2)"

    write_setting ".colors" "true"
    local -r toPrint="$(jq -r ".colors_on.${WTWITCH_LANG}" <<< "${TRANSLATIONS}")"
  fi

  printf "\n %b%s.%b\n" "${GREEN}" "${toPrint}" "${NC}"

  # Invalidate cache as it may or may not have colors
  write_setting ".lastSubscriptionUpdate" "null"
}

#######################################
# Unsubscribes from a specific streamer.
# Globals:
#   CONFIG_FILE
# Arguments:
#   $1: streamer to unsubscribe from
# Returns:
#   none
#######################################
unsubscribe()
{
  mapfile -t userSubscriptions <<< "$(jq -r ".subscriptions[].streamer" "${CONFIG_FILE}")"

  # Convert to lowercase
  local -r streamerToUnsubscribeFrom="${1,,}"

  # Find index of streamer in .subscriptions[]
  local whileCounter=0

  local currentSubscription
  currentSubscription="$(jq -r ".subscriptions[${whileCounter}].streamer" "${CONFIG_FILE}")"

  while [[ "${currentSubscription}" != "$streamerToUnsubscribeFrom" ]] && [[ "${currentSubscription}" != "null" ]]; do
    # Refresh data
    whileCounter="$(( whileCounter + 1 ))"
    currentSubscription="$(jq -r ".subscriptions[${whileCounter}].streamer" "${CONFIG_FILE}")"
  done

  # Check to make sure user is subscribed before unsubscribing
  if [[ ! $whileCounter -lt $(jq ".subscriptions | length" "${CONFIG_FILE}") ]]; then
    exit_script_on_failure "$(jq -r ".unsubscribe_failure.${WTWITCH_LANG}" <<< "${TRANSLATIONS}") ${streamerToUnsubscribeFrom}."
  fi

  # Remove subscription
  local -r tmpJson="$(jq "del(.subscriptions[${whileCounter}])" "${CONFIG_FILE}")"
  printf "%s" "${tmpJson}" > "${CONFIG_FILE}"

  # Invalidate cache
  write_setting ".lastSubscriptionUpdate" "null"
}

# -----------------------------------------
# ---------- Parse user options -----------
# -----------------------------------------

if [[ $# -eq 0 ]]; then
  print_help
  printf "%b" "${NC}" && exit 0
fi

# Parse flags. From:
# https://stackoverflow.com/questions/7069682/how-to-get-arguments-with-flags-in-bash/7069755#7069755
while [[ $# -gt 0 ]]; do
  case "$1" in
    -h|--help)
      print_help
      printf "%b" "${NC}" && exit 0
      break
      ;;
    -c|--check)
      check_twitch_streams
      printf "%b" "${NC}" && exit 0
      break
      ;;
    -g)
      shift
      if [[ $# -gt 0 ]]; then
        list_streamers_of_game "$1"
        printf "%b" "${NC}" && exit 0
      else
        exit_script_on_failure "$(jq -r ".flags_no_game.${WTWITCH_LANG}" <<< "${TRANSLATIONS}")."
      fi
      break
      ;;
    --get-streamers*)
      if [[ $# -gt 1 ]]; then
        shift
      fi
      if [[ $# -gt 0 ]]; then
        gameToCheck="$(extract_argument "$1")"
        list_streamers_of_game "${gameToCheck}"
      else
        exit_script_on_failure "$(jq -r ".flags_no_game.${WTWITCH_LANG}" <<< "${TRANSLATIONS}")."
      fi
      printf "%b" "${NC}" && exit 0
      break
      ;;
    -l|--toggle-colors)
      toggle_colors
      printf "%b" "${NC}" && exit 0
      break
      ;;
    -p)
      shift
      if [[ $# -gt 0 ]]; then
        change_player "$1"
        printf "%b" "${NC}" && exit 0
      else
        exit_script_on_failure "$(jq -r ".flags_no_player.${WTWITCH_LANG}" <<< "${TRANSLATIONS}")."
      fi
      break
      ;;
    --change-player*)
      if [[ $# -gt 1 ]]; then
        shift
      fi
      if [[ $# -gt 0 ]]; then
        player="$(extract_argument "$1")"
        change_player "${player}"
      else
        exit_script_on_failure "$(jq -r ".flags_no_player.${WTWITCH_LANG}" <<< "${TRANSLATIONS}")."
      fi
      printf "%b" "${NC}" && exit 0
      break
      ;;
    -q)
      shift
      if [[ $# -gt 0 ]]; then
        change_quality "$1"
        printf "%b" "${NC}" && exit 0
      else
        exit_script_on_failure "$(jq -r ".flags_no_quality.${WTWITCH_LANG}" <<< "${TRANSLATIONS}")."
      fi
      break
      ;;
    --change-quality*)
      if [[ $# -gt 1 ]]; then
        shift
      fi
      if [[ $# -gt 0 ]]; then
        quality="$(extract_argument "$1")"
        change_quality "${quality}"
      else
        exit_script_on_failure "$(jq -r ".flags_no_quality.${WTWITCH_LANG}" <<< "${TRANSLATIONS}")."
      fi
      printf "%b" "${NC}" && exit 0
      break
      ;;
    -s)
      shift
      if [[ $# -gt 0 ]]; then
        subscribe "$1"
        printf "%b" "${NC}" && exit 0
      else
        exit_script_on_failure "$(jq -r ".flags_no_streamer.${WTWITCH_LANG}" <<< "${TRANSLATIONS}")."
      fi
      break
      ;;
    --subscribe*)
      if [[ $# -gt 1 ]]; then
        shift
      fi
      if [[ $# -gt 0 ]]; then
        streamerToSubscribeTo="$(extract_argument "$1")"
        subscribe "${streamerToSubscribeTo}"
      else
        exit_script_on_failure "$(jq -r ".flags_no_streamer.${WTWITCH_LANG}" <<< "${TRANSLATIONS}")."
      fi
      printf "%b" "${NC}" && exit 0
      break
      ;;
    -t|--top)
      list_top
      printf "%b" "${NC}" && exit 0
      break
      ;;
    -u)
      shift
      if [[ $# -gt 0 ]]; then
        unsubscribe "$1"
        printf "%b" "${NC}" && exit 0
      else
        exit_script_on_failure "$(jq -r ".flags_no_streamer.${WTWITCH_LANG}" <<< "${TRANSLATIONS}")."
      fi
      break
      ;;
    --unsubscribe*)
      if [[ $# -gt 1 ]]; then
        shift
      fi
      if [[ $# -gt 0 ]]; then
        streamerToUnsubscribeFrom="$(extract_argument "$1")"
        unsubscribe "${streamerToUnsubscribeFrom}"
      else
        exit_script_on_failure "$(jq -r ".flags_no_streamer.${WTWITCH_LANG}" <<< "${TRANSLATIONS}")."
      fi
      printf "%b" "${NC}" && exit 0
      break
      ;;
    -v|--version)
      printf "wtwitch v%s\n" "${VERSION}"
      printf "Copyright (C) %s 2019-%s\n" "${CONTRIBUTORS}" "$(date +%Y)"
      printf "This is free software: you are free to change and redistribute it.\n"
      printf "There is NO WARRANTY, to the extent permitted by law.\n"
      printf "%b" "${NC}" && exit 0
      break
      ;;
    *)
      break
      ;;
  esac
done

# If quality="audio_only" OR debugging, do not open streamlink as a background process
if [[ "${userQuality}" == "audio_only" ]] || [[ "${DEBUGGING}" == "on" ]]; then
  stream "$1"
else
  stream "$1" &> /dev/null &
fi
